load("re.star", "re")
load("any.star", "any")
load("terraform.proto", TerraformProto="Terraform")
load("//protoconf_terraform/config/v1/config.proto", "SubscriptionConfig")

# Last is the last hook, which returns the component without calling next()
def Last(c, _):
    return c


def Chain(msg, *hooks):
    queue = list(hooks)

    def run_next(c):
        next = queue.pop(0)
        return next(c, run_next)

    first = queue.pop(0)
    return first(msg, run_next)


def ChainWithLast(msg, *hooks):
    return Chain(msg, *hooks + (Last,))


def Terraform(*hooks):
    tf = TerraformProto()

    return ChainWithLast(tf, *hooks)


def From(tf):
    def do(_, next):
        return next(tf)

    return do


def Provider(provider):
    def do(tf, next):
        if not tf.provider:
            tf.provider = TerraformProto.Providers()

        provider_name = str(provider).split(".")[1]
        providerlist = getattr(tf.provider, provider_name)
        providerlist.append(provider)
        return next(tf)

    return do


matchFirstCap = re.compile("(.)([A-Z][a-z]+)")
matchAllCap = re.compile("([a-z0-9])([A-Z])")


def toSnakeCase(snake):
    snake = matchFirstCap.sub("${1}_${2}", snake)
    snake = matchAllCap.sub("${1}_${2}", snake)
    return snake.lower()


def resource_type(resource):
    return toSnakeCase(str(resource).split()[0].split(".")[-1])


def link(name, resource, var=False):
    prefix = ".".join([resource_type(resource), name])
    return module(
        prefix,
        self=prefix,
        **dict(
            [
                (
                    field,
                    ".".join([prefix, field])
                    if not var
                    else "${%s}" % ".".join([prefix, field]),
                )
                for field in dir(resource)
            ]
        )
    )


def flatten(x):
    result = []
    for el in x:
        if type(el) == "list":
            result.extend(flatten(el))
        else:
            result.append(el)
    return result


def Resource(name, resource, *hooks):
    def do(tf, next):
        if not tf.resource:
            tf.resource = TerraformProto.Resources()
        resource_dict = getattr(tf.resource, resource_type(resource))
        resource_dict[name] = resource
        l = link(name, resource, True)

        subresources = [hook(l) for hook in hooks]
        tf = Terraform(From(tf), *flatten(subresources))

        return next(tf)

    return do


def Data(name, datasource):
    def do(tf, next):
        if tf.data:
            resource_dict = getattr(tf.data, resource_type(datasource))
            resource_dict[name] = datasource
        else:
            tf.data = TerraformProto.Datasources()
            return Data(name, datasource)

        return next(tf)

    return do


def Link(*hooks, **resources):
    def do(tf, next):
        tf = Terraform(
            From(tf),
            *[Resource(name, resource) for name, resource in resources.items()]
        )
        inputs = struct(
            resource=module("resources", **resources),
            link=module(
                "links",
                **dict(
                    [
                        (name, link(name, resource))
                        for name, resource in resources.items()
                    ]
                )
            ),
            var=module(
                "links",
                **dict(
                    [
                        (name, link(name, resource, True))
                        for name, resource in resources.items()
                    ]
                )
            ),
        )
        ChainWithLast(inputs, *hooks)

        return next(tf)

    return do


def Walk(component, func):
    func(component)
    for dep in component.upstreams:
        Walk(dep, func)


def GenerateTerraformConfigs(prefix, state, outputs, subscription_config_key_name="watch"):
    subscription_config=SubscriptionConfig(keys=[])

    def extract_config(component):
        for config_name, config in component.configs.items():
            if config.type_url == "type.googleapis.com/terraform.v1.Terraform":
                unpackedConfig = any.unpack(config, TerraformProto())

                # fixes a bug in any.pack which duplicates entries in repeated providers
                for providerType in dir(unpackedConfig.provider):
                    p = getattr(unpackedConfig.provider, providerType)
                    if p:
                        unpackedConfig.provider[providerType] = list(set(p))


                key="/".join([prefix, component.domain, component.name, config_name])
                outputs[key] = unpackedConfig
                subscription_config.keys.append(key)

    for domain in state.domains.values():
        Walk(domain.head, extract_config)

    outputs[subscription_config_key_name] = subscription_config
    return outputs


util = module(
    "Terraform", Terraform=Terraform, Provider=Provider, Resource=Resource, Link=Link
)
